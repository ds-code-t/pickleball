plugins {
    id 'java'
    id 'maven-publish'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
}

group = 'tools.dscode'
version = '1.0'

// Java 21 toolchain
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
    withSourcesJar()
    withJavadocJar()
}

// ----- Source sets: a tiny weaver-only set -----
sourceSets {
    main {
        java.srcDirs = ['src/main/java'] // optional
    }
    // All weaving logic lives here; it is build-time only.
    weaver {
        java.srcDir 'src/weaver/java'
        resources.srcDirs = []
    }
}

// Dependencies for the weaver (ByteBuddy etc.)
configurations {
    weaverImplementation.extendsFrom(configurations.implementation)
}

repositories {
    mavenLocal()
    mavenCentral()
}

// Pin Byte Buddy; add anything else the weaver needs at build time
dependencies {
    // Weaver build-time deps
    weaverImplementation 'net.bytebuddy:byte-buddy:1.14.19'
    weaverImplementation 'net.bytebuddy:byte-buddy-agent:1.14.19'

    // (Optional) utilities for the weaver; comment out if unused
    // weaverImplementation 'org.slf4j:slf4j-simple:2.0.16'
}

// Make archives reproducible
tasks.withType(AbstractArchiveTask).configureEach {
    preserveFileTimestamps = false
    reproducibleFileOrder = true
}

// We will publish only the shaded jar
tasks.jar {
    enabled = false
}

def forkJarsDir   = layout.buildDirectory.dir("fork-jars")
def weavedJarsDir = layout.buildDirectory.dir("weaved-jars")

tasks.register("buildFork") {
    group = "build"
    description = "Build forked cucumber reactor (selected core modules by path), collect target jars."
    outputs.dir(forkJarsDir)

    doLast {
        def isWindows = System.getProperty("os.name").toLowerCase(Locale.ROOT).contains("win")
        def userMaven = (findProperty("mavenExecutable") as String)?.trim()

        // Prefer repo-local Maven Wrapper in cucumber-jvm/
        def mvnwWin = file("cucumber-jvm/mvnw.cmd")
        def mvnwNix = file("cucumber-jvm/mvnw")

        List<String> mvnCmd
        if (userMaven) {
            mvnCmd = [userMaven]
        } else if (isWindows && mvnwWin.exists()) {
            mvnCmd = [mvnwWin.absolutePath]
        } else if (!isWindows && mvnwNix.exists()) {
            mvnwNix.setExecutable(true, true)
            mvnCmd = [mvnwNix.absolutePath]
        } else {
            mvnCmd = isWindows ? ["cmd", "/c", "mvn"] : ["mvn"]
        }

        // Core module directory names we typically need for weaving.
        // We will include only those that actually exist in your fork.
        def preferredDirs = [
                "cucumber-bom",                  // if present (bom is a POM-only aggregator)
                "cucumber-plugin",
                "cucumber-gherkin",
                "cucumber-gherkin-messages",
                "datatable",                     // many forks use 'datatable' (not 'cucumber-datatable')
                "docstring",                     // likewise 'docstring'
                "cucumber-core",
                "cucumber-java",
                "cucumber-junit-platform-engine",
                "cucumber-junit",
                "cucumber-testng",
                // keep your custom module if it’s in this repo:
                "cucumber-pickleball-common"
        ]

        // Exclude folders we definitely do not want to build
        def denyPatterns = ~/(?i)^(examples|archetype|wicket|compatibility|spring|guice|cdi|openejb|jakarta|pico|kotlin).*$/

        // Allow override from CLI if you want full control:
        // e.g. -PmvnModuleDirs="cucumber-core,cucumber-java"
        def cliDirs = (findProperty("mvnModuleDirs") as String)?.split("\\s*,\\s*")?.findAll { it }
        def baseDir = file("cucumber-jvm")

        // Select modules by path: only include existing directories and not denied ones
        def selected = (cliDirs ?: preferredDirs).collect { name ->
            new File(baseDir, name)
        }.findAll { it.exists() && new File(it, "pom.xml").exists() && !(it.name ==~ denyPatterns) }

        if (selected.isEmpty()) {
            throw new GradleException("No target modules found under ${baseDir}. " +
                    "Pass -PmvnModuleDirs=\"cucumber-core,cucumber-java\" with actual dir names from your fork.")
        }

        // Maven -pl accepts module paths. Build a comma-separated list of relative paths.
        def rel = { File f -> baseDir.toPath().relativize(f.toPath()).toString().replace('\\','/') }
        def modulePaths = selected.collect(rel).join(",")

        // Default Maven args: fast, skip tests
        List<String> baseArgs = [
                "-T","1C",
                "--no-transfer-progress",
                "-DskipTests=true",
                "clean","install",
                "-pl", modulePaths,
                "-am"
        ]

        // Allow extra args: -PmvnArgs="-Denforcer.skip=true"
        def extraArgs = (findProperty("mvnArgs") as String)?.split("\\s+")?.findAll { it?.trim() } ?: []

        println ">> Building cucumber-jvm module paths: ${modulePaths}"
        try {
            exec {
                workingDir = baseDir
                commandLine = mvnCmd + baseArgs + extraArgs
            }
        } catch (Exception e) {
            throw new GradleException(
                    "Maven execution failed. Tried: ${mvnCmd}\n" +
                            "If there are no modules at those paths, pass -PmvnModuleDirs with the correct directory names.",
                    e
            )
        }

        // Copy built jars you plan to weave into build/fork-jars
        copy {
            from fileTree(baseDir) {
                include "**/target/*.jar"
                exclude "**/*-sources.jar",
                        "**/*-javadoc.jar",
                        "**/*-tests.jar",
                        "**/*-original.jar",
                        "**/*-shaded.jar"
            }
            into forkJarsDir
        }
    }
}


// Stage dirs (keep these near the top of your build file)

// ----- Offline weaving via WeaveSpec -----
tasks.register("weaveCucumber", JavaExec) {
    group = "build"
    description = "Offline-weave target jars using WeaveSpec."

    dependsOn(tasks.named("buildFork"))
    classpath = sourceSets.weaver.runtimeClasspath
    mainClass = "tools.dscode.modkit.blackbox.WeaveSpec"

    // Declare inputs/outputs for incrementality
    inputs.files(forkJarsDir)
            .withPropertyName("forkJars")
            .withPathSensitivity(PathSensitivity.RELATIVE)
    inputs.files(sourceSets.weaver.output)
            .withPropertyName("weaverClasses")
    inputs.property("includes", (findProperty("weaveIncludes") ?: "io.cucumber."))
    inputs.property("debug", (findProperty("weaverDebug") ?: "false"))
    inputs.property("fixedTime", (findProperty("weaverFixedTime") ?: "true"))
    outputs.dir(weavedJarsDir)

    // JVM system props for the weaver
    jvmArgs "-Dweaver.debug=${findProperty('weaverDebug') ?: 'false'}",
            "-Dweaver.classpath=${(findProperty('weaverResolverPath') ?: '')}",
            "-Dweaver.fixedTime=${findProperty('weaverFixedTime') ?: 'true'}"

    // IMPORTANT: resolve Provider values at execution time, not at configuration time
    doFirst {
        def inDir  = forkJarsDir.get().asFile
        def outDir = weavedJarsDir.get().asFile
        outDir.mkdirs()

        // reset and pass args as TWO TOKENS per flag (no =)
        args = []
        args "--in", inDir.absolutePath,
                "--out", outDir.absolutePath,
                "--includes", (findProperty("weaveIncludes") ?: "io.cucumber.")

        println ">> weaveCucumber"
        println "   --in  ${inDir}"
        println "   --out ${outDir}"
        println "   --includes ${(findProperty('weaveIncludes') ?: 'io.cucumber.')}"
        println "   -Dweaver.debug=${findProperty('weaverDebug') ?: 'false'}"
        println "   -Dweaver.fixedTime=${findProperty('weaverFixedTime') ?: 'true'}"
    }

}

// Directory where we'll explode the weaved jars
def explodedWeavedDir = layout.buildDirectory.dir("weaved-exploded")

// Unpack all jars produced by weaveCucumber into a single folder
tasks.register("explodeWeavedJars", Sync) {
    group = "build"
    description = "Unpack weaved jars into a flat directory."
    dependsOn(tasks.named("weaveCucumber"))
    into(explodedWeavedDir)

    // Configure at configuration time using a Provider
    from(weavedJarsDir.map { dir ->
        // Collect zipTrees for every *.jar inside weaved-jars
        project.fileTree(dir).matching { include '**/*.jar' }.files.collect { zipTree(it) }
    })
}



// ----- Build the final single shaded artifact (no relocation) -----
tasks.shadowJar {
    group = "build"
    description = "Create the single pickleball jar from weaved jars."
    dependsOn(tasks.named("explodeWeavedJars"))

    archiveBaseName.set("pickleball")
    archiveClassifier.set("")
    archiveVersion.set(project.version as String)

    // Deterministic jar content
    preserveFileTimestamps = false
    reproducibleFileOrder = true

    // Merge SPI files
    mergeServiceFiles()

    // Drop existing signatures which are invalid after shading
    exclude "META-INF/*.SF", "META-INF/*.DSA", "META-INF/*.RSA"

    // ✅ Include the exploded classes/resources (configured at configuration time)
    from(explodedWeavedDir)

    // (No doFirst/doLast here—Shadow needs config-time specs only)
}


tasks.assemble {
    dependsOn(tasks.shadowJar)
}

// ----- Publishing: publish ONLY the shaded jar; no upstream cucumber deps -----
publishing {
    publications {
        create("maven", MavenPublication) {
            artifact tasks.shadowJar   // <-- no .get()

            groupId = project.group
            artifactId = "pickleball"
            version = project.version

            pom.withXml { xml ->
                def root = xml.asNode()

                // Remove any auto-inserted dependencies/dependencyManagement
                root.get('dependencies')?.each { root.remove(it) }
                root.get('dependencyManagement')?.each { root.remove(it) }

                // (Optional) add intentional API deps for consumers here, if any.
                // def deps = root.appendNode('dependencies')
                // def add = { g,a,v,s = null ->
                //   def d = deps.appendNode('dependency')
                //   d.appendNode('groupId', g); d.appendNode('artifactId', a); d.appendNode('version', v)
                //   if (s) d.appendNode('scope', s)
                // }
            }
        }
    }
    repositories {
        mavenLocal()
        // (Optional) add remote repo here
    }
}

// Convenience wiring
tasks.build {
    dependsOn(tasks.shadowJar)
}
tasks.publishToMavenLocal {
    dependsOn(tasks.shadowJar)
}

/*
Usage knobs:
 -PweaverDebug=true           -> per-class concise logs
 -PweaverFixedTime=false      -> preserve input times during weaving (default true uses epoch for reproducibility)
 -PweaveIncludes=io.cucumber.,io.cucumber.messages.  -> comma-separated package prefixes to consider for weaving
*/
