plugins {
    id 'java-library'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id 'maven-publish'
}

group = findProperty('group') ?: 'tools.dscode'
version = findProperty('version') ?: '1.0.0-SNAPSHOT'

repositories { mavenCentral() }

def cucumberVersion = findProperty('cucumberVersion') ?: '7.27.2'
def aspectjVersion = findProperty('aspectjVersion') ?: '1.9.24'
def messagesVersion = findProperty('messagesVersion') ?: '29.0.1'
def gherkinVersion = findProperty('gherkinVersion') ?: '35.1.0'

// List of modules to weave (add more entries here later)
def toWeave = [
        [group: 'io.cucumber', name: 'cucumber-core', version: cucumberVersion],
        [group: 'io.cucumber', name: 'cucumber-java', version: cucumberVersion],
        [group: 'io.cucumber', name: 'cucumber-plugin', version: cucumberVersion],
        [group: 'io.cucumber', name: 'messages', version: messagesVersion],
        [group: 'io.cucumber', name: 'gherkin', version: gherkinVersion],
]

java {
    toolchain { languageVersion = JavaLanguageVersion.of(21) }
}


/* ðŸ‘‡ Add this new block right after the java { } block */
sourceSets {
    main { java { srcDirs = ['src/main/java', 'src/main/aspectj'] } }
    test { java { srcDirs += ['src/test/aspectj'] } }
}


configurations {
    // JARs we want to weave (allow transitives for type resolution)
    weaveLibs {
        transitive = true
        exclude group: 'net.bytebuddy'
    }
    // AspectJ tool binaries (ajc)
    ajcTools
    // AspectJ runtime (needed on compile & weave CP; also shaded)
    ajcRuntime
}

dependencies {
    api("io.cucumber:cucumber-junit-platform-engine:7.27.2")
    api("org.junit.platform:junit-platform-suite-api:1.10.2")
    api("org.junit.platform:junit-platform-suite-engine:1.10.2")
    api("org.junit.jupiter:junit-jupiter-api:5.10.2")
    api("com.google.guava:guava:33.5.0-jre")
    api("com.fasterxml.jackson.core:jackson-databind:2.20.0")
    api("com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.20.0")
    api("com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.20.0")
    api("com.fasterxml.jackson.datatype:jackson-datatype-guava:2.20.0")
    api("com.googlecode.aviator:aviator:5.4.3")
    api("com.ibm.jsonata4java:JSONata4Java:2.6.0")
//    api("io.github.classgraph:classgraph:4.8.184")
    implementation("io.github.classgraph:classgraph:4.8.184")

    // AspectJ toolchain + runtime
    ajcTools "org.aspectj:aspectjtools:${aspectjVersion}"
    ajcRuntime "org.aspectj:aspectjrt:${aspectjVersion}"
    implementation "org.aspectj:aspectjrt:${aspectjVersion}" // shaded into pickleball

    // Declare weave targets, compile visibility, and runtime graph entries
    toWeave.each { gav ->
        weaveLibs "${gav.group}:${gav.name}:${gav.version}"
        compileOnly "${gav.group}:${gav.name}:${gav.version}"
        implementation "${gav.group}:${gav.name}:${gav.version}"
    }

    // BOM for alignment (optional but nice to keep)
    implementation platform("io.cucumber:cucumber-bom:${cucumberVersion}")
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

tasks.register('ajcMain', JavaExec) {
    group = 'build'
    description = 'Compile Java + AspectJ (main) with ajc'

    def outDir = sourceSets.main.java.destinationDirectory.get().asFile
    outputs.dir(outDir)

    mainClass.set('org.aspectj.tools.ajc.Main')
    classpath = configurations.ajcTools

    def cp = files(sourceSets.main.compileClasspath, configurations.ajcRuntime).asPath

    // ðŸ‘‡ Use ONLY what sourceSets already knows (includes aspectj dir)
    def allSourceRoots = sourceSets.main.java.srcDirs
            .collect { it.absolutePath }
            .join(File.pathSeparator)

    args = [
            '-21',
            '-sourceroots', allSourceRoots,
            '-d', outDir.absolutePath,
            '-classpath', cp,
            '-Xlint:ignore'
    ]
}

// Disable javacâ€”ajc produces the class files
tasks.named('compileJava').configure { enabled = false }
// Make lifecycle compile depend on ajc
tasks.named('classes') { dependsOn 'ajcMain' }

// --- BINARY WEAVING OF DEPENDENCY JARS (unchanged in spirit) ---

def wovenDir = layout.buildDirectory.dir('woven')
def wovenExpanded = layout.buildDirectory.dir('woven-expanded')

tasks.register('weaveTargets', JavaExec) {
    group = 'build'
    description = 'Weaves ALL target jars with compiled aspects in one AJC run'
    dependsOn 'ajcMain'
    outputs.dir(wovenDir)

    doFirst { wovenDir.get().asFile.mkdirs() }

    def inpathFiles = provider {
        def artifacts = configurations.weaveLibs
                .resolvedConfiguration
                .resolvedArtifacts
        def wanted = toWeave.collect { "${it.group}:${it.name}:${it.version}" } as Set
        artifacts.findAll { ra ->
            "${ra.moduleVersion.id.group}:${ra.name}:${ra.moduleVersion.id.version}" in wanted
        }.collect { it.file }
    }

    mainClass.set('org.aspectj.tools.ajc.Main')
    classpath = configurations.ajcTools

    def outJar = wovenDir.map { it.file("all-woven.jar") }.get().asFile
    def classesDir = sourceSets.main.java.destinationDirectory.get().asFile

    // Resolution CP includes your compiled classes (types used by aspects)
    def weaverClasspath = files(
            configurations.weaveLibs,
            configurations.ajcRuntime,
            classesDir
    ).asPath

    args = [
            '-showWeaveInfo',
            '-verbose',
            '-Xlint:warning',

            '-inpath', files(inpathFiles).asPath,

            // aspects bytecode: your compiled classes contain the aspects now
            '-aspectpath', files(classesDir).asPath,

            // resolution classpath
            '-classpath', weaverClasspath,

            '-outjar', outJar.absolutePath
    ]
}

// Expand the woven jars before shadowJar runs (same as before)
tasks.register('expandWoven', Sync) {
    group = 'build'
    description = 'Expands woven jar into a staging directory for shading'
    dependsOn 'weaveTargets'
    into(wovenExpanded)
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    from({
        def jar = new File(wovenDir.get().asFile, 'all-woven.jar')
        zipTree(jar)
    }) {
        exclude 'META-INF/*.SF', 'META-INF/*.RSA', 'META-INF/*.DSA'
        exclude 'META-INF/MANIFEST.MF'
    }
}

tasks.shadowJar {
    // use ajc output + woven deps
    dependsOn 'ajcMain', 'expandWoven', 'classes'

    archiveBaseName.set('pickleball')
    archiveVersion.set(project.version.toString())
    archiveClassifier.set('') // publish as main artifact

    // âœ… include classes AND resources (keeps META-INF/services/*)
    from(sourceSets.main.output) {
        includeEmptyDirs = false
    }

    // put woven classes LAST so they overwrite any originals
    from(wovenExpanded)
    duplicatesStrategy = DuplicatesStrategy.INCLUDE  // last-wins merge

    // Only shade what we really need
    dependencies {
        exclude(dependency("io.cucumber:cucumber-core:${cucumberVersion}"))
        exclude(dependency("io.cucumber:cucumber-java:${cucumberVersion}"))
        exclude(dependency("io.cucumber:cucumber-plugin:${cucumberVersion}"))
        exclude(dependency("io.cucumber:messages:${messagesVersion}"))
        exclude(dependency("io.cucumber:gherkin:${gherkinVersion}"))
    }

    // âœ… ensure service descriptors are merged for discovery
    mergeServiceFiles {
        include 'META-INF/services/io.cucumber.core.backend.Backend'
        include 'META-INF/services/io.cucumber.core.backend.ObjectFactory'
        include 'META-INF/services/org.junit.platform.engine.TestEngine'
    }

    exclude 'META-INF/*.SF', 'META-INF/*.RSA', 'META-INF/*.DSA'
    zip64 = true
}


// Disable the plain jar so only the shaded jar is produced/published
tasks.jar { enabled = false }

// Publish shaded artifact; POM massaging kept as-is
publishing {
    publications {
        create('maven', MavenPublication) { pub ->
            groupId = project.group as String
            artifactId = 'pickleball'
            version = project.version as String

            project.shadow.component(pub)

            pom.withXml {
                def pomNode = asNode()

                groovy.util.Node depsNode
                def depsNodeList = pomNode.get('dependencies') as groovy.util.NodeList
                if (depsNodeList && depsNodeList.size() > 0) {
                    depsNode = (groovy.util.Node) depsNodeList[0]
                } else {
                    depsNode = pomNode.appendNode('dependencies')
                }

                Set<String> existing = depsNode.children()
                        .findAll { it instanceof groovy.util.Node && ((groovy.util.Node) it).name() == 'dependency' }
                        .collect { n ->
                            def node = (groovy.util.Node) n
                            "${node.get('groupId')[0].text()}:${node.get('artifactId')[0].text()}"
                        } as Set

//                Set<String> shadedGA = (['org.aspectj:aspectjrt'] + toWeave.collect { "${it.group}:${it.name}" }) as Set
                Set<String> shadedGA = (
                        ['org.aspectj:aspectjrt', 'io.github.classgraph:classgraph'] +
                                toWeave.collect { "${it.group}:${it.name}" }
                ) as Set

                def rtArtifacts = configurations.runtimeClasspath
                        .resolvedConfiguration
                        .resolvedArtifacts
                        .findAll { ra ->
                            def ga = "${ra.moduleVersion.id.group}:${ra.name}"
                            !shadedGA.contains(ga) &&
                                    !(ra.moduleVersion.id.group == project.group && ra.name == 'pickleball')
                        }

                rtArtifacts.each { ra ->
                    def ga = "${ra.moduleVersion.id.group}:${ra.name}"
                    if (!existing.contains(ga)) {
                        def d = depsNode.appendNode('dependency')
                        d.appendNode('groupId', ra.moduleVersion.id.group)
                        d.appendNode('artifactId', ra.name)
                        d.appendNode('version', ra.moduleVersion.id.version)
                        d.appendNode('scope', 'compile')
                    }
                }
            }

            pom {
                name.set('pickleball')
                description.set('Shaded, AspectJ-woven Cucumber bundle (overrides selected modules; publishes all other runtime deps for Maven consumers)')
                url.set('https://example.org/pickleball')
                licenses {
                    license {
                        name.set('Apache License, Version 2.0')
                        url.set('https://www.apache.org/licenses/LICENSE-2.0')
                    }
                }
            }
        }
    }
    repositories { mavenLocal() }
}


apply plugin: 'idea'

// Ensure woven jar exists when IDEA syncs
tasks.named('ideaModule') { dependsOn 'weaveTargets' }

configurations { wovenInsight }

dependencies {
    // Put your woven classes into an IDE-only configuration
    wovenInsight files("$buildDir/woven/all-woven.jar")
}

idea {
    module {
        // Make sure the AspectJ folder stays a source root in IDEA
        sourceDirs += file('src/main/aspectj')

        // â–¶ Add woven classes to IDE classpath for code insight
        scopes.COMPILE.plus += [configurations.wovenInsight]
        scopes.RUNTIME.plus += [configurations.wovenInsight]
        // â–¶ Remove the *unwoven* jars from IDE classpath (build remains unchanged)
        scopes.COMPILE.minus += [configurations.weaveLibs]
        scopes.RUNTIME.minus += [configurations.weaveLibs]
    }
}


// Lifecycle
tasks.assemble { dependsOn tasks.shadowJar }
tasks.test { useJUnitPlatform() }
