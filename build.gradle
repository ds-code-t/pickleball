plugins {
    id 'java-library'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id 'maven-publish'
}

group   = findProperty('group')    ?: 'tools.dscode'
version = findProperty('version')  ?: '1.0.0-SNAPSHOT'

repositories { mavenCentral() }

def cucumberVersion = findProperty('cucumberVersion') ?: '7.27.2'
def aspectjVersion  = findProperty('aspectjVersion')  ?: '1.9.21'
def messagesVersion  = findProperty('aspectjVersion')  ?: '29.0.1'
def gherkinVersion  = findProperty('aspectjVersion')  ?: '35.1.0'

// List of modules to weave (add more entries here later)
def toWeave = [
        [group: 'io.cucumber', name: 'cucumber-core', version: cucumberVersion],
        [group: 'io.cucumber', name: 'cucumber-java', version: cucumberVersion],
        [group: 'io.cucumber', name: 'cucumber-plugin', version: cucumberVersion],
        [group: 'io.cucumber', name: 'messages', version: messagesVersion],
        [group: 'io.cucumber', name: 'gherkin', version: gherkinVersion],
]

java {
    toolchain { languageVersion = JavaLanguageVersion.of(21) }
}

configurations {
    // JARs we want to weave (allow transitives for type resolution)
    weaveLibs {
        transitive = true
        exclude group: 'net.bytebuddy'
        // important: resolve only at execution time in tasks (Gradle 9 safe)
    }
    // AspectJ tool binaries (ajc)
    ajcTools
    // AspectJ runtime (needed on compile & weave CP; also shaded)
    ajcRuntime
}

dependencies {
    api("io.cucumber:cucumber-junit-platform-engine:7.27.2")
    api("org.junit.platform:junit-platform-suite-api:1.10.2")
    api("org.junit.platform:junit-platform-suite-engine:1.10.2")
    api("org.junit.jupiter:junit-jupiter-api:5.10.2")
    api("com.google.guava:guava:33.5.0-jre")
    api("com.fasterxml.jackson.core:jackson-databind:2.20.0")
    api("com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.20.0")
    api("com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.20.0")
    api("com.fasterxml.jackson.datatype:jackson-datatype-guava:2.20.0")
    api("com.googlecode.aviator:aviator:5.4.3")
    api("com.ibm.jsonata4java:JSONata4Java:2.6.0")


    // AspectJ toolchain + runtime
    ajcTools    "org.aspectj:aspectjtools:${aspectjVersion}"
    ajcRuntime  "org.aspectj:aspectjrt:${aspectjVersion}"
    implementation "org.aspectj:aspectjrt:${aspectjVersion}" // shaded into pickleball

    // Declare weave targets, compile visibility, and runtime graph entries
    toWeave.each { gav ->
        weaveLibs      "${gav.group}:${gav.name}:${gav.version}"
        compileOnly    "${gav.group}:${gav.name}:${gav.version}"
        implementation "${gav.group}:${gav.name}:${gav.version}"
    }

    // BOM for alignment (optional but nice to keep)
    implementation platform("io.cucumber:cucumber-bom:${cucumberVersion}")
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

def aspectsSrcDir = file('src/main/aspectj')
def aspectsOutDir = layout.buildDirectory.dir('classes-aspectj/main')

// Compile .aj sources with AJC
tasks.register('compileAspects', JavaExec) {
    group = 'build'
    description = 'Compiles AspectJ sources'
    // ensure your Java helpers are compiled first
    dependsOn 'classes'

    inputs.dir(aspectsSrcDir)
    outputs.dir(aspectsOutDir)

    mainClass.set('org.aspectj.tools.ajc.Main')
    classpath = configurations.ajcTools

    doFirst { aspectsOutDir.get().asFile.mkdirs() }

    // resolvable compile CP + AspectJ runtime + your compiled Java helpers
    def cp = files(
            sourceSets.main.compileClasspath,
            sourceSets.main.output,     // <â€” your Java classes available to aspects
            configurations.ajcRuntime
    ).asPath

    args = [
            // Change to '-release','17' if you want 17-level bytecode
            '-21',
            '-sourceroots', aspectsSrcDir.absolutePath,
            '-d', aspectsOutDir.get().asFile.absolutePath,
            '-classpath', cp,
            '-Xlint:ignore'
    ]
}

def wovenDir      = layout.buildDirectory.dir('woven')
def wovenExpanded = layout.buildDirectory.dir('woven-expanded')

tasks.register('weaveTargets', JavaExec) {
    group = 'build'
    description = 'Weaves ALL target jars with compiled aspects in one AJC run'
    dependsOn 'compileAspects'
    outputs.dir(wovenDir)

    doFirst { wovenDir.get().asFile.mkdirs() }

    def inpathFiles = provider {
        def artifacts = configurations.weaveLibs
                .resolvedConfiguration
                .resolvedArtifacts
        def wanted = toWeave.collect { "${it.group}:${it.name}:${it.version}" } as Set
        artifacts.findAll { ra ->
            "${ra.moduleVersion.id.group}:${ra.name}:${ra.moduleVersion.id.version}" in wanted
        }.collect { it.file }
    }

    mainClass.set('org.aspectj.tools.ajc.Main')
    classpath = configurations.ajcTools

    def outJar = wovenDir.map { it.file("all-woven.jar") }.get().asFile

    // ðŸ‘‡ include your compiled classes so RunnerExtras is resolvable
    def weaverClasspath = files(
            configurations.weaveLibs,
            configurations.ajcRuntime,
            sourceSets.main.output            // <â€” ADD THIS
    ).asPath

    args = [
            '-showWeaveInfo',
            '-verbose',
            '-Xlint:warning',

            '-inpath', files(inpathFiles).asPath,

            // aspects bytecode
            '-aspectpath', files(
            aspectsOutDir.get().asFile,
            sourceSets.main.output          // (optional) safe to include here too
    ).asPath,

            // resolution classpath (must include your own types like RunnerExtras)
            '-classpath', weaverClasspath,

            '-outjar', outJar.absolutePath
    ]
}


// Expand the woven jars before shadowJar runs (configure-time safe)
tasks.register('expandWoven', Sync) {
    group = 'build'
    description = 'Expands woven jar into a staging directory for shading'
    dependsOn 'weaveTargets'
    into(wovenExpanded)
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    from({
        def jar = new File(wovenDir.get().asFile, 'all-woven.jar')
        zipTree(jar)
    }) {
        exclude 'META-INF/*.SF', 'META-INF/*.RSA', 'META-INF/*.DSA'
        exclude 'META-INF/MANIFEST.MF'
    }
}

tasks.shadowJar {
    dependsOn 'expandWoven', 'compileAspects', 'classes'

    archiveBaseName.set('pickleball')
    archiveVersion.set(project.version.toString())
    archiveClassifier.set('') // publish as main artifact

    // include your compiled Java helpers
    from(sourceSets.main.output) {
        include '**/*.class'
        includeEmptyDirs = false
    }

    // include the compiled aspects
    from(aspectsOutDir) {
        include '**/*.class'
    }

    // put woven classes LAST so they overwrite any originals
    from(wovenExpanded)
    duplicatesStrategy = DuplicatesStrategy.INCLUDE  // last-wins merge

    // Only shade what we really need:
    //  - include AspectJ runtime so consumers don't add it
    //  - EXCLUDE original cucumber-core/java to avoid overwriting woven classes
    dependencies {
        include(dependency("org.aspectj:aspectjrt:${aspectjVersion}"))
        exclude(dependency("io.cucumber:cucumber-core:${cucumberVersion}"))
        exclude(dependency("io.cucumber:cucumber-java:${cucumberVersion}"))
        exclude(dependency("io.cucumber:cucumber-plugin:${cucumberVersion}"))
        exclude(dependency("io.cucumber:messages:${messagesVersion}"))
        exclude(dependency("io.cucumber:gherkin:${gherkinVersion}"))
    }

    mergeServiceFiles()
    exclude 'META-INF/*.SF', 'META-INF/*.RSA', 'META-INF/*.DSA'
    zip64 = true
}


// Disable the plain jar so only the shaded jar is produced/published
tasks.jar { enabled = false }

// Publish the SHADOW component and ensure all *other* runtime deps
// (everything on runtimeClasspath except the shaded ones) are present in the POM.
publishing {
    publications {
        create('maven', MavenPublication) { pub ->
            groupId    = project.group as String
            artifactId = 'pickleball'
            version    = project.version as String

            // Publish the shaded jar with dependency-reduced POM baseline
            project.shadow.component(pub)

            // Add back all non-shaded runtime dependencies so Maven consumers get them
            pom.withXml {
                def pomNode = asNode()

                // Get or create a single <dependencies> node
                groovy.util.Node depsNode
                def depsNodeList = pomNode.get('dependencies') as groovy.util.NodeList
                if (depsNodeList && depsNodeList.size() > 0) {
                    depsNode = (groovy.util.Node) depsNodeList[0]
                } else {
                    depsNode = pomNode.appendNode('dependencies')
                }

                // Existing deps (GA) to avoid duplicates
                Set<String> existing = depsNode.children()
                        .findAll { it instanceof groovy.util.Node && ((groovy.util.Node) it).name() == 'dependency' }
                        .collect { n ->
                            def node = (groovy.util.Node) n
                            "${node.get('groupId')[0].text()}:${node.get('artifactId')[0].text()}"
                        } as Set

                // Which modules are shaded (and thus should NOT be listed)
                Set<String> shadedGA = (['org.aspectj:aspectjrt'] + toWeave.collect { "${it.group}:${it.name}" }) as Set

                // Walk the resolved runtime classpath and add everything except shaded parents
                def rtArtifacts = configurations.runtimeClasspath
                        .resolvedConfiguration
                        .resolvedArtifacts
                        .findAll { ra ->
                            def ga = "${ra.moduleVersion.id.group}:${ra.name}"
                            !shadedGA.contains(ga) &&
                                    !(ra.moduleVersion.id.group == project.group && ra.name == 'pickleball')
                        }

                rtArtifacts.each { ra ->
                    def ga = "${ra.moduleVersion.id.group}:${ra.name}"
                    if (!existing.contains(ga)) {
                        def d = depsNode.appendNode('dependency')
                        d.appendNode('groupId',    ra.moduleVersion.id.group)
                        d.appendNode('artifactId', ra.name)
                        d.appendNode('version',    ra.moduleVersion.id.version)
                        d.appendNode('scope',      'compile')
                    }
                }
            }

            pom {
                name.set('pickleball')
                description.set('Shaded, AspectJ-woven Cucumber bundle (overrides selected modules; publishes all other runtime deps for Maven consumers)')
                url.set('https://example.org/pickleball')
                licenses {
                    license {
                        name.set('Apache License, Version 2.0')
                        url.set('https://www.apache.org/licenses/LICENSE-2.0')
                    }
                }
            }
        }
    }
    repositories { mavenLocal() }
}

// Lifecycle
tasks.assemble { dependsOn tasks.shadowJar }
tasks.test { useJUnitPlatform() }
