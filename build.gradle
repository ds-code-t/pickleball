plugins {
    id 'java-library'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id 'maven-publish'
    id 'signing'
    id("io.github.gradle-nexus.publish-plugin") version "2.0.0"
}

group = 'tools.dscode'
version = '2.0.3'


repositories {
    mavenCentral()
//    maven { url 'https://jitpack.io' }
}

def cucumberVersion = findProperty('cucumberVersion') ?: '7.27.2'
def aspectjVersion = findProperty('aspectjVersion') ?: '1.9.24'
def messagesVersion = findProperty('messagesVersion') ?: '29.0.1'
def gherkinVersion = findProperty('gherkinVersion') ?: '35.1.0'

// List of modules to weave (add more entries here later)
def toWeave = [
        [group: 'io.cucumber', name: 'cucumber-core', version: cucumberVersion],
        [group: 'io.cucumber', name: 'cucumber-java', version: cucumberVersion],
        [group: 'io.cucumber', name: 'cucumber-plugin', version: cucumberVersion],
        [group: 'io.cucumber', name: 'messages', version: messagesVersion],
        [group: 'io.cucumber', name: 'gherkin', version: gherkinVersion],
]

java {
    toolchain { languageVersion = JavaLanguageVersion.of(21) }

    // Maven Central expects these companion artifacts
    withSourcesJar()
    withJavadocJar()
}



// Optional: make javadoc generation less fragile on modern JDKs
tasks.withType(Javadoc).configureEach {
    options.addStringOption('Xdoclint:none', '-quiet')
    options.encoding = 'UTF-8'
}

/* ðŸ‘‡ Add this new block right after the java { } block */
sourceSets {
    main { java { srcDirs = ['src/main/java', 'src/main/aspectj'] } }
    test { java { srcDirs += ['src/test/aspectj'] } }
}


configurations {
    // JARs we want to weave (allow transitives for type resolution)
    weaveLibs {
        transitive = true
        exclude group: 'net.bytebuddy'
    }
    // AspectJ tool binaries (ajc)
    ajcTools
    // AspectJ runtime (needed on compile & weave CP; also shaded)
    ajcRuntime
}

dependencies {
    api("io.cucumber:cucumber-junit-platform-engine:${cucumberVersion}") {
        // Prevent consumers from pulling the UNWOVEN cucumber internals transitively
        exclude group: "io.cucumber", module: "cucumber-core"
        exclude group: "io.cucumber", module: "cucumber-java"
        exclude group: "io.cucumber", module: "cucumber-plugin"
        exclude group: "io.cucumber", module: "messages"
        exclude group: "io.cucumber", module: "gherkin"
    }


    api("org.junit.platform:junit-platform-suite-api:1.10.2")
    api("org.junit.platform:junit-platform-suite-engine:1.10.2")
    api("org.junit.jupiter:junit-jupiter-api:5.10.2")
    api("com.google.guava:guava:33.5.0-jre")
    api("com.fasterxml.jackson.core:jackson-databind:2.20.0")
    api("com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.20.0")
    api("com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.20.0")
    api("com.fasterxml.jackson.datatype:jackson-datatype-guava:2.20.0")
    api("com.googlecode.aviator:aviator:5.4.3")
    api("com.ibm.jsonata4java:JSONata4Java:2.6.0")

    // data formatting
    api 'org.jetbrains:annotations:26.0.2-1'

    // service calls
    api('com.salesforce.revoman:revoman:0.81.0')
    api('io.rest-assured:rest-assured:6.0.0')

    // logging and reports
    api "com.aventstack:extentreports:5.1.2"
    api 'com.epam.reportportal:client-java:5.4.8'
    api  'org.apache.logging.log4j:log4j-core:2.25.3'

    implementation("io.github.classgraph:classgraph:4.8.184")
    implementation("org.apache.poi:poi-ooxml:5.5.1")

    // AspectJ toolchain + runtime
    ajcTools "org.aspectj:aspectjtools:${aspectjVersion}"
    ajcRuntime "org.aspectj:aspectjrt:${aspectjVersion}"
//    implementation "org.aspectj:aspectjrt:${aspectjVersion}" // shaded into pickleball

// Declare weave targets + compile visibility (but DO NOT publish as transitive deps)
// The woven bytecode is bundled into the shadow jar via from(wovenExpanded).
    toWeave.each { gav ->
        weaveLibs  "${gav.group}:${gav.name}:${gav.version}"
        compileOnly "${gav.group}:${gav.name}:${gav.version}"
        testImplementation "${gav.group}:${gav.name}:${gav.version}" // only if your tests need it
    }


// Align all io.cucumber modules in THIS build, and also share alignment intent with consumers (Gradle)
    api(platform("io.cucumber:cucumber-bom:${cucumberVersion}"))



    // xpath and selenium
    implementation('org.seleniumhq.selenium:selenium-java') {
        version { strictly('[4.0,5.0)') }
    }

    implementation files('libs/xpathy-3.0.0.jar')

}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

tasks.register('ajcMain', JavaExec) {
    group = 'build'
    description = 'Compile Java + AspectJ (main) with ajc'

    def outDir = sourceSets.main.java.destinationDirectory.get().asFile
    outputs.dir(outDir)

    mainClass.set('org.aspectj.tools.ajc.Main')
    classpath = configurations.ajcTools

    def cp = files(sourceSets.main.compileClasspath, configurations.ajcRuntime).asPath

    // ðŸ‘‡ Use ONLY what sourceSets already knows (includes aspectj dir)
    def allSourceRoots = sourceSets.main.java.srcDirs
            .collect { it.absolutePath }
            .join(File.pathSeparator)

    args = [
            '-21',
            '-sourceroots', allSourceRoots,
            '-d', outDir.absolutePath,
            '-classpath', cp,
            '-Xlint:ignore'
    ]
}

// Disable javacâ€”ajc produces the class files
tasks.named('compileJava').configure { enabled = false }
// Make lifecycle compile depend on ajc
tasks.named('classes') { dependsOn 'ajcMain' }

// --- BINARY WEAVING OF DEPENDENCY JARS (unchanged in spirit) ---

def wovenDir = layout.buildDirectory.dir('woven')
def wovenExpanded = layout.buildDirectory.dir('woven-expanded')

tasks.register('weaveTargets', JavaExec) {
    group = 'build'
    description = 'Weaves ALL target jars with compiled aspects in one AJC run'
    dependsOn 'ajcMain'
    outputs.dir(wovenDir)

    doFirst { wovenDir.get().asFile.mkdirs() }

    def inpathFiles = provider {
        def artifacts = configurations.weaveLibs
                .resolvedConfiguration
                .resolvedArtifacts
        def wanted = toWeave.collect { "${it.group}:${it.name}:${it.version}" } as Set
        artifacts.findAll { ra ->
            "${ra.moduleVersion.id.group}:${ra.name}:${ra.moduleVersion.id.version}" in wanted
        }.collect { it.file }
    }

    mainClass.set('org.aspectj.tools.ajc.Main')
    classpath = configurations.ajcTools

    def outJar = wovenDir.map { it.file("all-woven.jar") }.get().asFile
    def classesDir = sourceSets.main.java.destinationDirectory.get().asFile

    // Resolution CP includes your compiled classes (types used by aspects)
    def weaverClasspath = files(
            configurations.weaveLibs,
            configurations.ajcRuntime,
            classesDir
    ).asPath

    args = [
            '-showWeaveInfo',
            '-verbose',
            '-Xlint:warning',

            '-inpath', files(inpathFiles).asPath,

            // aspects bytecode: your compiled classes contain the aspects now
            '-aspectpath', files(classesDir).asPath,

            // resolution classpath
            '-classpath', weaverClasspath,

            '-outjar', outJar.absolutePath
    ]
}

// Expand the woven jars before shadowJar runs (same as before)
tasks.register('expandWoven', Sync) {
    group = 'build'
    description = 'Expands woven jar into a staging directory for shading'
    dependsOn 'weaveTargets'
    into(wovenExpanded)
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    from({
        def jar = new File(wovenDir.get().asFile, 'all-woven.jar')
        zipTree(jar)
    }) {
        exclude 'META-INF/*.SF', 'META-INF/*.RSA', 'META-INF/*.DSA'
        exclude 'META-INF/MANIFEST.MF'
    }
}


def myLicense = file("LICENSE").canonicalFile
def myNotice  = file("NOTICE").canonicalFile

tasks.shadowJar {
    configurations = [project.configurations.ajcRuntime]

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    // Exclude LICENSE/NOTICE coming from dependency jars, but keep *your* project ones.
    exclude { FileTreeElement e ->
        def p = e.path

        // Match common license/notice paths that appear in dependency jars
        boolean looksLikeLicenseOrNotice =
                p == 'LICENSE' ||
                        p == 'NOTICE' ||
                        p.startsWith('META-INF/LICENSE') ||
                        p.startsWith('META-INF/NOTICE') ||
                        p ==~ /(?i)^LICENSE(\..+)?$/ ||
                        p ==~ /(?i)^NOTICE(\..+)?$/ ||
                        p ==~ /(?i)^META-INF\/LICENSE(\..+)?$/ ||
                        p ==~ /(?i)^META-INF\/NOTICE(\..+)?$/

        if (!looksLikeLicenseOrNotice) return false

        // Keep the project's own LICENSE/NOTICE (wherever you copy them)
        File src = e.file
        if (src != null && src.exists()) {
            def c = src.canonicalFile
            if (c == myLicense || c == myNotice) return false
        }

        // Otherwise: it's from a dependency -> exclude it
        return true
    }

    // Now you can safely add yours
    from("LICENSE") { into "META-INF" }
    from("NOTICE") { into "META-INF" }
    from("THIRD-PARTY-NOTICES.md") { into "META-INF" }

    // use ajc output + woven deps
    dependsOn 'ajcMain', 'expandWoven', 'classes'

    archiveBaseName.set('pickleball')
    archiveVersion.set(project.version.toString())
    archiveClassifier.set('') // publish as main artifact

    // âœ… include classes AND resources (keeps META-INF/services/*)
    from(sourceSets.main.output) {
        includeEmptyDirs = false
    }


    // Bundle local xpathy jar into the shaded jar (since Maven consumers can't resolve files(...) deps)
    from({ zipTree(file("libs/xpathy-3.0.0.jar")) }) {
        // keep signatures out (common for shaded jars)
        exclude 'META-INF/*.SF', 'META-INF/*.RSA', 'META-INF/*.DSA'
        // optional: avoid duplicate manifests
        exclude 'META-INF/MANIFEST.MF'
    }

    // put woven classes LAST so they overwrite any originals
    from(wovenExpanded)


    // âœ… ensure service descriptors are merged for discovery
    mergeServiceFiles()


    exclude 'META-INF/*.SF', 'META-INF/*.RSA', 'META-INF/*.DSA'
    zip64 = true


}


// Disable the plain jar so only the shaded jar is produced/published
tasks.jar { enabled = false }

// Publish shaded artifact; POM massaging kept as-is
publishing {
    repositories {
        maven {
            name = "staging"
            url = layout.buildDirectory.dir("maven-central-staging")
        }
    }

    publications {
        create('maven', MavenPublication) { pub ->
            groupId = project.group as String
            artifactId = 'pickleball'
            version = project.version as String

            // Publish the shaded jar as THE main artifact
            artifact(tasks.named("shadowJar")) {
                builtBy tasks.named("shadowJar")
            }

            // Also publish sources + javadoc jars (expected by Central)
            artifact(tasks.named("sourcesJar"))
            artifact(tasks.named("javadocJar"))

            pom {
                name.set('pickleball')
                description.set('Shaded, AspectJ-woven Cucumber bundle (overrides selected modules; publishes all other runtime deps for Maven consumers)')
                url.set('https://github.com/ds-code-t/pickleball')

                licenses {
                    license {
                        name.set('Apache License, Version 2.0')
                        url.set('https://www.apache.org/licenses/LICENSE-2.0')
                    }
                }

                scm {
                    url.set('https://github.com/ds-code-t/pickleball')
                    connection.set('scm:git:git://github.com/ds-code-t/pickleball.git')
                    developerConnection.set('scm:git:ssh://git@github.com/ds-code-t/pickleball.git')
                }

                developers {
                    developer {
                        id.set('ds-code-t')
                        name.set('DSCode Tools')
                        url.set('https://github.com/ds-code-t')
                    }
                }
            }

            // --- FIX: Build a correct POM dependencies list ---
            pom.withXml {
                def pomNode = asNode()

                // Ensure <dependencies> exists
                def depsNodeList = pomNode.get('dependencies') as groovy.util.NodeList
                def depsNode = (depsNodeList && depsNodeList.size() > 0)
                        ? (groovy.util.Node) depsNodeList[0]
                        : pomNode.appendNode('dependencies')

                // Remove anything Gradle/Shadow may have inserted (we're taking control)
                depsNode.children().clear()

                // Coordinates you bundle/override -> must NOT be published as transitive deps
                Set<String> bundledOrOverriddenGA = (
                        ['org.aspectj:aspectjrt'] +                 // shaded via ajcRuntime
                                ['io.cucumber:cucumber-bom'] +              // don't publish BOM as a normal dep
                                toWeave.collect { "${it.group}:${it.name}" } // woven cucumber/messages/gherkin
                ) as Set

                // Collect declared direct deps you want to publish transitively:
                // - api deps (exposed to consumers)
                // - implementation deps (turnkey runtime; also visible if you want)
                def declared = []
                declared.addAll(configurations.api.allDependencies)
                declared.addAll(configurations.implementation.allDependencies)

                // Helper: resolve a version ONLY when needed (and allowed)
                def resolvedVersionFor = { String g, String a ->
                    def ra = configurations.runtimeClasspath
                            .resolvedConfiguration
                            .resolvedArtifacts
                            .find { it.moduleVersion.id.group == g && it.name == a }
                    return ra?.moduleVersion?.id?.version
                }

                // De-dupe by GA
                Set<String> added = new LinkedHashSet<>()

                declared.each { dep ->
                    // Skip non-module deps (files(...), project deps, etc.)
                    if (!(dep instanceof org.gradle.api.artifacts.ModuleDependency)) return
                    if (!dep.group || !dep.name) return

                    String ga = "${dep.group}:${dep.name}"

                    // Skip anything you bundle/override
                    if (bundledOrOverriddenGA.contains(ga)) return

                    if (added.contains(ga)) return
                    added.add(ga)

                    // Decide version string:
                    String versionString

                    // âœ… Selenium floats for consumers
                    if (ga == "org.seleniumhq.selenium:selenium-java") {
                        versionString = "[4.0,5.0)"
                    } else {
                        // Use declared version when present
                        versionString = dep.version

                        // If version is missing due to constraints/BOM, fall back to resolved version
                        if (!versionString) {
                            versionString = resolvedVersionFor(dep.group, dep.name)
                        }
                    }

                    if (!versionString) {
                        throw new GradleException("Cannot determine version for published dependency: ${ga}")
                    }

                    def d = depsNode.appendNode('dependency')
                    d.appendNode('groupId', dep.group)
                    d.appendNode('artifactId', dep.name)
                    d.appendNode('version', versionString)

                    // For your "turnkey framework" goal, compile scope is fine
                    d.appendNode('scope', 'compile')

                    // ---- Exclusions handling (single shared <exclusions> node) ----
                    def existingExcls = d.get('exclusions') as groovy.util.NodeList
                    def exclsNode = (existingExcls && existingExcls.size() > 0)
                            ? (groovy.util.Node) existingExcls[0]
                            : null

                    // âœ… Always exclude the woven cucumber internals from the engine dependency in the published POM
                    if (ga == "io.cucumber:cucumber-junit-platform-engine") {
                        if (exclsNode == null) exclsNode = d.appendNode('exclusions')

                        [
                                "io.cucumber:cucumber-core",
                                "io.cucumber:cucumber-java",
                                "io.cucumber:cucumber-plugin",
                                "io.cucumber:messages",
                                "io.cucumber:gherkin"
                        ].each { gav ->
                            def (eg, ea) = gav.split(':', 2)
                            def ex = exclsNode.appendNode('exclusion')
                            ex.appendNode('groupId', eg)
                            ex.appendNode('artifactId', ea)
                        }
                    }

                    // Carry excludes if you ever add them on deps
                    if (dep.excludeRules && !dep.excludeRules.isEmpty()) {
                        if (exclsNode == null) exclsNode = d.appendNode('exclusions')

                        dep.excludeRules.each { er ->
                            def ex = exclsNode.appendNode('exclusion')
                            ex.appendNode('groupId', er.group ?: '*')
                            ex.appendNode('artifactId', er.module ?: '*')
                        }
                    }
                }
            }


        }
    }
}




apply plugin: 'idea'

// Ensure woven jar exists when IDEA syncs
tasks.named('ideaModule') { dependsOn 'weaveTargets' }

configurations { wovenInsight }

dependencies {
    // Put your woven classes into an IDE-only configuration
    wovenInsight files("$buildDir/woven/all-woven.jar")
}

idea {
    module {
        // Make sure the AspectJ folder stays a source root in IDEA
        sourceDirs += file('src/main/aspectj')

        // â–¶ Add woven classes to IDE classpath for code insight
        scopes.COMPILE.plus += [configurations.wovenInsight]
        scopes.RUNTIME.plus += [configurations.wovenInsight]
        scopes.TEST.plus    += [configurations.wovenInsight]   // âœ… add this

        // â–¶ Remove the *unwoven* jars from IDE classpath (build remains unchanged)
        scopes.COMPILE.minus += [configurations.weaveLibs]
        scopes.RUNTIME.minus += [configurations.weaveLibs]
        scopes.TEST.minus    += [configurations.weaveLibs]     // âœ… add this
    }
}




nexusPublishing {
    repositories {
        sonatype {
            // Most OSSRH accounts use s01; if your account is on the older host, change these to oss.sonatype.org
            nexusUrl.set(uri("https://s01.oss.sonatype.org/service/local/"))
            snapshotRepositoryUrl.set(uri("https://s01.oss.sonatype.org/content/repositories/snapshots/"))

            username.set((findProperty("ossrhUsername") ?: System.getenv("OSSRH_USERNAME"))?.toString())
            password.set((findProperty("ossrhPassword") ?: System.getenv("OSSRH_PASSWORD"))?.toString())
        }
    }
}

// Decide what kind of publish this build is doing (based on requested task names)
def requested = gradle.startParameter.taskNames*.toLowerCase()

def isMavenLocalPublish =
        requested.any { it.contains("publishtomavenlocal") }

def isStagingPublish =
        requested.any { it.contains("publishmavenpublicationtostagingrepository") } ||
                requested.any { it.contains("publishallpublicationstostagingrepository") } ||
                requested.any { it.contains("closeandrelease") } ||
                requested.any { it.contains("releasesonatype") } ||
                requested.any { it.contains("publishsonatype") }

// If you *only* want signing for staging, keep it this strict:
def signingIsRequired = isStagingPublish && !isMavenLocalPublish



signing {
    // Only require signing for the staging / Central flow
    required { signingIsRequired }

    def key  = (findProperty("signingKey") ?: System.getenv("SIGNING_KEY"))?.toString()
    def pass = (findProperty("signingPassword") ?: System.getenv("SIGNING_PASSWORD"))?.toString()

    // Only configure keys when we actually intend to sign
    if (signingIsRequired) {
        if (!key) {
            throw new GradleException(
                    "Signing is required for staging publish, but no signingKey/SIGNING_KEY was provided."
            )
        }
        useInMemoryPgpKeys(key, pass)
        sign(publishing.publications.named("maven").get())
    }
}



import java.security.MessageDigest

def checksumFiles = { File f ->
    def algos = ['MD5':'md5', 'SHA-1':'sha1']
    algos.each { algo, ext ->
        def md = MessageDigest.getInstance(algo)
        f.withInputStream { is ->
            byte[] buf = new byte[8192]
            int r
            while ((r = is.read(buf)) > 0) md.update(buf, 0, r)
        }
        def hex = md.digest().collect { String.format("%02x", it) }.join()
        new File(f.parentFile, "${f.name}.${ext}").text = hex
    }
}

def centralStagingDir = layout.buildDirectory.dir("maven-central-staging")

tasks.register("generateCentralChecksums") {
    group = "publishing"
    description = "Generate .md5 and .sha1 checksums for Central upload bundle (excluding .asc and existing checksums)."
    dependsOn "publishMavenPublicationToStagingRepository"

    doLast {
        File root = centralStagingDir.get().asFile
        if (!root.exists()) {
            throw new GradleException("Staging directory does not exist: ${root}")
        }

        fileTree(root).matching {
            include "**/*"
            exclude "**/*.md5", "**/*.sha1", "**/*.sha256", "**/*.sha512"
            exclude "**/*.asc"                 // .asc should NOT have checksums :contentReference[oaicite:1]{index=1}
            exclude "**/maven-metadata.xml*"
        }.files.findAll { it.isFile() }.each { f ->
            checksumFiles(f)
        }
    }
}


tasks.register("centralBundleZip", Zip) {
    group = "publishing"
    description = "Create a Sonatype Central upload bundle zip from the local staging repository output."

    dependsOn "generateCentralChecksums"

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    archiveFileName.set("pickleball-${project.version}-central-bundle.zip")
    destinationDirectory.set(layout.buildDirectory.dir("central-bundle"))

    from(layout.buildDirectory.dir("maven-central-staging")) {
        exclude "**/maven-metadata.xml*"
        exclude "**/*.asc.md5", "**/*.asc.sha1", "**/*.asc.sha256", "**/*.asc.sha512"
    }
}







// Lifecycle
tasks.assemble { dependsOn tasks.shadowJar }


// If we're only doing publishToMavenLocal, never run signing tasks
tasks.withType(Sign).configureEach {
    onlyIf { !isMavenLocalPublish }
}


tasks.test {
    useJUnitPlatform()
    dependsOn("expandWoven") // expandWoven already dependsOn weaveTargets

    // Put woven classes FIRST so they beat the unwoven dependency jars
    classpath = files(wovenExpanded) + classpath
}


configurations.named("testRuntimeClasspath") {
    exclude group: "io.cucumber", module: "cucumber-core"
    exclude group: "io.cucumber", module: "cucumber-java"
    exclude group: "io.cucumber", module: "cucumber-plugin"
    exclude group: "io.cucumber", module: "messages"
    exclude group: "io.cucumber", module: "gherkin"
}

//configurations.named("testCompileClasspath") {
//    exclude group: "io.cucumber", module: "cucumber-core"
//    exclude group: "io.cucumber", module: "cucumber-java"
//    exclude group: "io.cucumber", module: "cucumber-plugin"
//    exclude group: "io.cucumber", module: "messages"
//    exclude group: "io.cucumber", module: "gherkin"
//}

